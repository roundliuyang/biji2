# MongoDB 最佳实践



作为MongoDB的一名方案架构师，我的大部分时间都是在和MongoDB的客户和用户交互。在这里，我希望通过一个不断更新的活文章的方式来为大家收集整理一下MongoDB开发及维护时候值得了解或者遵从的一些最佳实践。



## 关于安全



### 为MongoDB集群启用认证鉴权

MongoDB服务器在默认安装下不启用鉴权。这意味着每个人都可以直接连接到mongod实例并执行任意数据库操作。建议按照文档启用鉴权 http://docs.mongoing.com/manual-zh/tutorial/enable-authentication.html



### 为不同用户分配不同的角色权限

MongoDB支持按角色定义的权限系统。你应该基于“最少权限”准则，显式的为用户分配仅需要的相应权限。



### 使用中央鉴权服务器

尽可能使用LDAP、Kerbero之类的中央鉴权服务器，并使用强口令策略。



### 为需要访问MongoDB的应用服务器创建白名单（防火墙配置）

如果你的服务器有多个网卡，建议只在内网的IP上监听服务。



### 对敏感数据使用加密引擎

MongoDB企业版支持存储加密，对涉及到客户的敏感数据应该使用加密引擎来保护数据。





## 关于部署



### 至少使用3个数据节点的复制集

MongoDB的建议最小部署是3个数据节点构成的复制集。复制集可以提供以下优点：

- 系统99.999% 高可用
- 自动故障切换
- 数据冗余
- 容灾部署
- 读写分离



### 不用太早分片

分片可以用来扩展你系统的读写能力，但是分片也会带来不少新的挑战比如说管理上的复杂度，成本的增加，选择合适片键的挑战性等等。一般来说，你应该先穷尽了其他的性能调优的选项以后才开始考虑分片，比如说，索引优化，模式优化，代码优化，硬件资源优化，IO优化等。



### 选择合适的分片数

分片的一些触发条件为：

- 数据总量太大，无法在一台服务器上管理
- 并发量太高，一台服务器无法及时处理
- 磁盘IO压力太大
- 单机系统内存不够大，无法装下热数据
- 服务器网卡处理能力达到瓶颈
- 多地部署情况下希望支持本地化读写

取决于你分片的触发条件，你可以按照总的需求 然后除以每一台服务器的能力来确定所需的分片数。



## 关于开发



### 模式设计



#### 不要按照关系型来设计表结构

MongoDB可以让你像关系型数据库一样设计表结构，但是它不支持外键，也不支持复杂的Join！如果你的程序发现有大量实用JOIN的地方，那你的设计可能需要重新来过。参照以下相关模式设计建议。



#### 数据库集合（collection）的数量不宜太多

MongoDB的模式设计基于灵活丰富的JSON文档模式。在很多情况下，一个MongoDB应用的数据库内的集合（表）的数量应该远远小于使用关系数据库的同类型应用。MongoDB表设计不遵从第三范式。MongoDB的数据模型非常接近于对象模型，所以基本上就是按照主要的Domain object的数量来建相应的集合。根据经验，一般小型应用的集合数量通常在几个之内，中大型的应用会在10多个或者最多几十个。



#### 不要害怕数据冗余

MongoDB模式设计不能按照第三范式，很多时候允许数据在多个文档中重复，比如说，在每一个员工的文档中重复他的部门名字，就是一个可以接受的做法。如果部门名字改了，可以执行一个update({},{}, {multi:true}) 的多文档更新来一次性把部门名字更新掉。



#### 适合和不适合冗余的数据类型

一般来说，如果某个字段的数据值经常会变，则不太适合被大量冗余到别的文档或者别的集合里面去。举例来说，如果我们是在做一些股票类型资产管理， 可能有很多人都购买了Apple的股票，但是如果把经常变动的股价冗余到客户的文档里，由于股票价格变动频繁，会导致有大量的更新操作。从另外一个角度来说，如果是一些不经常变的字段，如客户的姓名，地址，部门等，则可以尽管进行冗余shi’yang



#### 对 1：N（一些）的关系使用全部内嵌

对于一对多的关系，如一个人有几个联系方式，一本书有10几个章节，等等，建议使用内嵌方式，把N的数据以数组形式来描述，如：

```json
> db.person.findOne()
{
  user_id: 'tjworks',
  name: 'TJ Tang',
  contact : [
     { type: 'mobile', number: '1856783691' },
     { type: 'wechat', number: 'tjtang826'}
  ]
}
```



#### 对 1: NN (很多) 的关系使用ID内嵌

有些时候这个一对多的多端数量较大， 比如说，一个部门内有多少员工。在华为一个三级部门可能有数千员工，这个时候如果把所有员工信息直接内嵌到部门内肯定不是个好的选择，有可能会超出16MB的文档限制。这个时候可以采用引用ID的方式：

```json
> db.departments.findOne()
{
    name : 'Enterprise BG',
    president: 'Zhang San',
    employees : [     // array of references to Employee colletion
        ObjectID('AAAA'),
        ObjectID('F17C'),
        ObjectID('D2AA'),
        // etc
    ]
}
```

如果需要查询部门下员工相关信息，你可以使用$lookup聚合操作符来把员工信息进行关联并返回。



#### 对 1: NNN (很多) 的关系使用

如果一对多情况下，这个多端数量无限大并会频繁增长，比如说，一个测量仪的每分钟读数，一年下来有几十万条，这个时候即使是把ID放到数组里都会管理不便，这个时候就应该把多端的数据创建一个集合，并在那个集合的文档里加入对主文档的连接引用，如：

```json
> db.sensors.findOne()
{
    _id : ObjectID('AAAB'),
    name : 'engine temperature',
    vin : '4GD93039GI239',
    engine_id: '20394802',
    manuafacture: 'First Motor',
    production_date: '2014-02-01'
    ...
}

>db.readings.findOne()
{
    time : ISODate("2014-03-28T09:42:41.382Z"),
    sensor: ObjectID('AAAB'),
    reading: 67.4
}
```







### 程序配置



#### 设定合适的MongoDB连接池大小 （Connections Per Host）

Java驱动的默认连接池大小是100。建议按照应用的实际情况做调整。对压力较小的应用可以适当调小减少对应用服务器的资源占用。