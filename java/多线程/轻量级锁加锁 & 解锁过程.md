# è½»é‡çº§é”åŠ é” & è§£é”è¿‡ç¨‹

`è½»é‡çº§é”`æ˜¯å¯¹ synchronized çš„ä¸€ç§ä¼˜åŒ–æœºåˆ¶ï¼Œå®ƒæ˜¯ä¸€ç§ä¹è§‚é”ï¼Œé€‚ç”¨äºå¤šçº¿ç¨‹ç«äº‰æ¯”è¾ƒå¼±çš„æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç›¸å¯¹äºä¼ ç»Ÿçš„é‡é‡çº§äº’æ–¥é”ï¼ˆä½¿ç”¨æ“ä½œç³»ç»Ÿäº’æ–¥é‡åŠ é”ï¼‰ï¼Œè½»é‡çº§é”çš„æ€§èƒ½æ›´å¥½ã€‚

è½»é‡çº§é”é€šè¿‡æ“ä½œåŠ é”å¯¹è±¡çš„å¯¹è±¡å¤´ä¸­çš„ `Mark Word `è¿›è¡ŒåŠ é”ã€‚åœ¨ HotSpot è™šæ‹Ÿæœºä¸­ï¼Œå¯¹è±¡å¤´åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šä¸€éƒ¨åˆ†ç”¨äºå­˜å‚¨å¯¹è±¡è‡ªèº«çš„è¿è¡Œæ—¶æ•°æ® (ä¾‹å¦‚ hashcodeã€GC Age ç­‰)ï¼Œå®ƒçš„ä½æ•°å’Œè™šæ‹Ÿæœºçš„ä½æ•°å¯¹åº”ï¼Œè¿™éƒ¨åˆ†æ•°æ®å«åš`ã€ŒMark Wordã€`ã€‚å¦ä¸€éƒ¨åˆ†ç”¨äºå­˜å‚¨æŒ‡å‘æ–¹æ³•åŒºå¯¹è±¡ç±»å‹æ•°æ®çš„æŒ‡é’ˆã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå¯¹äºæ•°ç»„å¯¹è±¡ï¼Œè¿˜ä¼šå­˜å‚¨æ•°ç»„çš„é•¿åº¦ã€‚



## Mark Word çš„ä¸åŒçŠ¶æ€

å¦‚ä¸‹æ˜¯ 32 ä½ HotSpot è™šæ‹Ÿæœºä¸­` Mark Word` åœ¨ä¸åŒçŠ¶æ€ä¸‹å­˜å‚¨çš„ä¿¡æ¯ï¼š

| é”çŠ¶æ€   | 25 bit                       | 4bit         | 1bit         | 2bit |      |
| -------- | ---------------------------- | ------------ | ------------ | ---- | ---- |
| 23bit    | 2bit                         | æ˜¯å¦æ˜¯åå‘é” | é”æ ‡å¿—ä½     |      |      |
| æ— é”     | å¯¹è±¡çš„ hashCode              | å¯¹è±¡åˆ†ä»£å¹´é¾„ | 0            | 01   |      |
| åå‘é”   | çº¿ç¨‹ ID                      | Epoch        | å¯¹è±¡åˆ†ä»£å¹´é¾„ | 1    | 01   |
| è½»é‡çº§é” | æŒ‡å‘æ ˆä¸­é”è®°å½•çš„æŒ‡é’ˆ         | 00           |              |      |      |
| é‡é‡çº§é” | æŒ‡å‘äº’æ–¥é‡ï¼ˆé‡é‡çº§é”ï¼‰çš„æŒ‡é’ˆ | 10           |              |      |      |
| GC æ ‡è®°  | ç©º                           | 11           |              |      |      |

**synchronized** æœ‰ 4 ç§é”çŠ¶æ€ï¼Œä»ä½åˆ°é«˜åˆ†åˆ«ä¸ºï¼š**æ— é”çŠ¶æ€**ã€**åå‘é”çŠ¶æ€**ã€**è½»é‡çº§é”çŠ¶æ€**ã€**é‡é‡çº§é”çŠ¶æ€**ï¼Œé”å¯ä»¥å‡çº§ä½†ä¸èƒ½é™çº§ã€‚æœ¬æ–‡ä¸»è¦è®¨è®ºçš„æ˜¯è½»é‡çº§é”çš„åŠ é”å’Œè§£é”è¿‡ç¨‹ã€‚

## è½»é‡çº§é”åŠ é”

**è½»é‡çº§é”åŠ **é”çš„å‰ææ˜¯é”å¯¹è±¡ä¸èƒ½å¸¦æœ‰åå‘ç‰¹å¾ã€‚åŠ é”çš„è¿‡ç¨‹å¯åˆ†ä¸ºä¸¤ç§æƒ…å†µæ¥è®¨è®ºï¼šä¸€ç§æ˜¯æ— é”çŠ¶æ€ (é”æ ‡å¿—ä½ä¸º 01ï¼Œåå‘æ ‡å¿—ä½ä¸º 0)ï¼Œå¯ç›´æ¥å°è¯•åŠ é”ã€‚å¦ä¸€ç§æ˜¯æœ‰é”çŠ¶æ€ï¼Œéœ€æ£€æŸ¥æ˜¯å¦ä¸ºå½“å‰çº¿ç¨‹æŒæœ‰çš„è½»é‡çº§é”ã€‚

```c++
assert(!mark->has_bias_pattern(), "should not see bias pattern here");
```



### æ— é”çŠ¶æ€

æ— é”çŠ¶æ€ä¸‹ï¼Œé”æ ‡å¿—ä½ä¸º 01ï¼Œåå‘æ ‡å¿—ä½ä¸º 0ï¼Œå¯ç›´æ¥å°è¯•åŠ é”



#### Mark Word åˆå§‹çŠ¶æ€

ä»£ç è¿›å…¥åŒæ­¥å—æ—¶ï¼ŒåŒæ­¥å¯¹è±¡å¤„äºæ— é”çŠ¶æ€ï¼Œé”æ ‡å¿—ä½ä¸º â€œ01â€ï¼Œåå‘æ ‡å¿—ä½ä¸º â€œ0â€

![image-20200323001907541](è½»é‡çº§é”åŠ é” & è§£é”è¿‡ç¨‹.assets/image-20200323001907541.png)

#### å»ºç«‹é”è®°å½•

ç¬¬ä¸€æ­¥ï¼šåœ¨åŠ é”å‰ï¼Œè™šæ‹Ÿæœºéœ€è¦åœ¨å½“å‰çº¿ç¨‹çš„æ ˆå¸§ä¸­å»ºç«‹**é”è®°å½•**ï¼ˆLock Recordï¼‰çš„ç©ºé—´ã€‚Lock Record ä¸­åŒ…å«ä¸€ä¸ª `_displaced_header` å±æ€§ï¼Œç”¨äºå­˜å‚¨é”å¯¹è±¡çš„ Mark Word çš„æ‹·è´ã€‚

![image-20200323002018621](è½»é‡çº§é”åŠ é” & è§£é”è¿‡ç¨‹.assets/image-20200323002018621.png)

#### å¤åˆ¶é”å¯¹è±¡çš„ Mark Word

ç¬¬äºŒæ­¥ï¼šå°†é”å¯¹è±¡çš„ Mark Word å¤åˆ¶åˆ°é”è®°å½•ä¸­ï¼Œè¿™ä¸ªå¤åˆ¶è¿‡æ¥çš„è®°å½•å«åš Displaced Mark Wordã€‚å…·ä½“æ¥è®²ï¼Œæ˜¯å°† mark word æ”¾åˆ°é”è®°å½•çš„ `_displaced_header` å±æ€§ä¸­ã€‚

![image-20200323002049050](è½»é‡çº§é”åŠ é” & è§£é”è¿‡ç¨‹.assets/image-20200323002049050.png)

```c++
// å°†Mark Wordä¿å­˜åœ¨é”è®°å½•ä¸­
lock->set_displaced_header(mark);
```

```c++
class BasicLock VALUE_OBJ_CLASS_SPEC {
  friend class VMStructs;
 private:
  volatile markOop _displaced_header;
 public:
  void         set_displaced_header(markOop header)   { _displaced_header = header; }
  ......  
};
```



#### CAS æ›´æ–°é”å¯¹è±¡çš„ Mark Word

ç¬¬ä¸‰æ­¥ï¼šè™šæ‹Ÿæœºä½¿ç”¨ CAS æ“ä½œå°è¯•å°†é”å¯¹è±¡çš„ Mark Word æ›´æ–°ä¸ºæŒ‡å‘**é”è®°å½•**çš„æŒ‡é’ˆã€‚å¦‚æœæ›´æ–°æˆåŠŸï¼Œè¿™ä¸ªçº¿ç¨‹å°±è·å¾—äº†è¯¥å¯¹è±¡çš„é”

![image-20200323002116692](è½»é‡çº§é”åŠ é” & è§£é”è¿‡ç¨‹.assets/image-20200323002116692.png)

```c++
// lock: æŒ‡å‘Lock Recordçš„æŒ‡é’ˆ
// obj()->mark_addr(): é”å¯¹è±¡çš„Mark Wordåœ°å€
// mark: é”å¯¹è±¡çš„Mark Word
if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {
    TEVENT (slow_enter: release stacklock) ;
    return ;
}
```



### æœ‰é”çŠ¶æ€

æœ‰é”çŠ¶æ€ä¸‹ï¼Œå¦‚æœæ˜¯å½“å‰çº¿ç¨‹æŒæœ‰çš„è½»é‡çº§é”ï¼Œåˆ™è¯´æ˜æ˜¯é‡å…¥ï¼Œä¸éœ€è¦äº‰æŠ¢é”ã€‚å¦åˆ™ï¼Œè¯´æ˜æœ‰å¤šä¸ªçº¿ç¨‹ç«äº‰ï¼Œè½»é‡çº§é”éœ€è¦å‡çº§ä¸ºé‡é‡çº§é”ã€‚



#### å½“å‰çº¿ç¨‹æŒæœ‰é”

å¯¹åº”æ— é”çŠ¶æ€çš„ç¬¬äºŒæ­¥ï¼šé”å¯¹è±¡å¤„äºåŠ é”çŠ¶æ€ï¼Œå¹¶ä¸”é”å¯¹è±¡çš„ Mark Word æŒ‡å‘å½“å‰çº¿ç¨‹çš„æ ˆå¸§èŒƒå›´å†…ï¼Œè¯´æ˜å½“å‰çº¿ç¨‹å·²ç»æŒæœ‰è¯¥è½»é‡çº§é”ï¼Œå†æ¬¡è·å–åˆ°è¯¥é”ï¼Œä¹Ÿå°±æ˜¯é”é‡å…¥ã€‚

![image-20200323002141347](è½»é‡çº§é”åŠ é” & è§£é”è¿‡ç¨‹.assets/image-20200323002141347.png)

æ­¤æ—¶ä¸éœ€è¦äº‰æŠ¢é”ï¼Œå¯æ‰§è¡ŒåŒæ­¥ä»£ç 

```c++
// Mark Word å¤„äºåŠ é”çŠ¶æ€ï¼Œå½“å‰çº¿ç¨‹æŒæœ‰çš„é”(Mark Word æŒ‡å‘çš„æ˜¯å½“å‰çº¿ç¨‹çš„æ ˆå¸§åœ°å€èŒƒå›´)
if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
  assert(lock != mark->locker(), "must not re-lock the same lock");
  assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");
  // é”é‡å…¥ï¼Œå°† Displaced Mark Word è®¾ç½®ä¸º null
  lock->set_displaced_header(NULL);
  return;
}
```

æ¯æ¬¡è·å–è½»é‡çº§é”æ—¶éƒ½ä¼šåˆ›å»ºä¸€ä¸ª Lock Recordï¼Œé”é‡å…¥æ—¶ä¼šåˆ›å»ºå¤šä¸ªæŒ‡å‘åŒä¸€ä¸ª Object çš„ Lock Recordï¼Œé™¤ç¬¬ä¸€æ¬¡è®¾ç½® `Displaced Mark Word` ï¼Œåé¢å‡è®¾ç½®ä¸º null



#### ä¸æ˜¯å½“å‰çº¿ç¨‹æŒæœ‰çš„é”

ä¸Šä¸€ç§æ¡ä»¶ä¸æ»¡è¶³ï¼Œè¯´æ˜å­˜åœ¨å¤šä¸ªçº¿ç¨‹ç«äº‰é”ï¼Œè½»é‡çº§é”è¦è†¨èƒ€äº†ã€‚å¯¹ï¼å°±æ˜¯ inflate è†¨èƒ€äº†ï¼ :laughing: è†¨èƒ€æˆé‡é‡çº§é”åå†åŠ é”

```c++
// The object header will never be displaced to this lock,
// so it does not matter what the value is, except that it
// must be non-zero to avoid looking like a re-entrant lock,
// and must not look locked either.
lock->set_displaced_header(markOopDesc::unused_mark());
ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);
```



## è½»é‡çº§é”è§£é”

è§£é”çš„æ€è·¯æ˜¯ä½¿ç”¨ CAS æ“ä½œæŠŠå½“å‰çº¿ç¨‹çš„æ ˆå¸§ä¸­çš„ `Displaced Mark Word` æ›¿æ¢å›é”å¯¹è±¡ä¸­å»ï¼Œå¦‚æœæ›¿æ¢æˆåŠŸï¼Œåˆ™è§£é”æˆåŠŸã€‚



### CAS æ›¿æ¢å› Mark Word

![image-20200323002205988](è½»é‡çº§é”åŠ é” & è§£é”è¿‡ç¨‹.assets/image-20200323002205988.png)

```c++
...
mark = object->mark() ;

// If the object is stack-locked by the current thread, try to
// swing the displaced header from the box back to the mark.
if (mark == (markOop) lock) {
  assert (dhw->is_neutral(), "invariant") ;
  // å°† Displaced Mark Word æ›¿æ¢å›å»
  if ((markOop) Atomic::cmpxchg_ptr (dhw, object->mark_addr(), mark) == mark) {
    TEVENT (fast_exit: release stacklock) ;
    return;
  }
}
```



### æ›¿æ¢å¤±è´¥

æ›¿æ¢å¤±è´¥ï¼Œè½»é‡çº§é”è†¨èƒ€æˆé‡é‡çº§é”åå†è§£é”

```c++
ObjectSynchronizer::inflate(THREAD, object)->exit (true, THREAD) ;
```



### é”é‡å…¥

å¦‚ä¸Šæ–‡æ‰€è®²ï¼šåŠ é”æ—¶ï¼Œå¦‚æœæ˜¯é”é‡å…¥ï¼Œä¼šå°† `Displaced Mark Word` è®¾ç½®ä¸º nullã€‚ç›¸å¯¹åº”åœ°ï¼Œè§£é”æ—¶ï¼Œå¦‚æœåˆ¤æ–­ `Displaced Mark Word` ä¸º null åˆ™è¯´æ˜æ˜¯é”é‡å…¥ï¼Œä¸åšæ›¿æ¢æ“ä½œ

```c++
markOop dhw = lock->displaced_header();
markOop mark ;
if (dhw == NULL) {
    // Recursive stack-lock.
    // Diagnostics -- Could be: stack-locked, inflating, inflated.
    mark = object->mark() ;
    assert (!mark->is_neutral(), "invariant") ;
    if (mark->has_locker() && mark != markOopDesc::INFLATING()) {
      assert(THREAD->is_lock_owned((address)mark->locker()), "invariant") ;
    }
    if (mark->has_monitor()) {
      ObjectMonitor * m = mark->monitor() ;
      assert(((oop)(m->object()))->mark() == mark, "invariant") ;
      assert(m->is_entered(THREAD), "invariant") ;
    }
    return ;
}
```



## å‚è€ƒä»£ç 

**bytecodeInterpreter.cpp**

ä»£ç ä½ç½®ï¼š`hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp`

```c++
/* monitorenter and monitorexit for locking/unlocking an object */
CASE(_monitorenter): {
    ...

    // traditional lightweight locking
    if (!success) {
      markOop displaced = lockee->mark()->set_unlocked();
      entry->lock()->set_displaced_header(displaced);
      bool call_vm = UseHeavyMonitors;
      if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {
        // Is it simple recursive case?
        if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
          entry->lock()->set_displaced_header(NULL);
        } else {
          // è½»é‡çº§é”åŠ é”
          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
        }
      }
      ...
  }
  ...
}
```

**interpreterRuntime.cpp**

ä»£ç ä½ç½®ï¼š `hotspot/src/share/vm/interpreter/interpreterRuntime.cpp`

```c++
if (UseBiasedLocking) {
  // Retry fast entry if bias is revoked to avoid unnecessary inflation
  ObjectSynchronizer::fast_enter(h_obj, elem->lock(), true, CHECK);
} else {
  // è½»é‡çº§é”åŠ é”
  ObjectSynchronizer::slow_enter(h_obj, elem->lock(), CHECK);
}
```

å¦‚æœä½¿ç”¨åå‘é”ï¼Œåˆ™è¿›å…¥ fast_enter ä»£ç é€»è¾‘ï¼Œå¦åˆ™è¿›å…¥ slow_enter è½»é‡çº§é”åŠ é”é€»è¾‘



### **å‚è€ƒ**

https://gorden5566.com/post/1019.html

> å‘¨å¿—æ˜ã€‚æ·±å…¥ç†è§£ Java è™šæ‹Ÿæœº
> [æ­»ç£• Synchronized åº•å±‚å®ç°ï¼šè½»é‡çº§é”](https://github.com/farmerjohngit/myblog/issues/14)
> [(å…­) synchronized çš„æºç åˆ†æ](https://mp.weixin.qq.com/s?__biz=MzUxNDA1NDI3OA==&mid=2247484986&idx=3&sn=565359c429b80736ffc16c46fb0d8591&chksm=f94a87d3ce3d0e)

ç›¸å…³æ–‡ç« 

- [å…³äºè½»é‡çº§é”çš„ä¸€äº›é—®é¢˜](https://gorden5566.com/post/post/1057.html)

  

  

### é—®ç­”

**Tsingxin**

æ‚¨å¥½ï¼Œæƒ³è¯·é—®ä¸€ä¸‹ï¼Œè½»é‡çº§é”è§£é”è¿‡ç¨‹ï¼ŒCAS æ›¿æ¢å› Mark Wordï¼Œæ˜¯åœ¨ä»€ä¹ˆæƒ…å†µä¸‹å¯¼è‡´çš„æ›¿æ¢å¤±è´¥å‘¢ï¼Ÿ

**gorden5566**

[@Tsingxin](https://gorden5566.com/post/1019.html#5efb44cdfd84ef0008413f18) , è¿™ä¸ªCASæ›¿æ¢æ“ä½œå¯ä»¥åˆ†ä¸º3æ­¥

1. è·å–é”å¯¹è±¡çš„ mark word
2. åˆ¤æ–­ mark word æ­£æ˜¯æŒ‡å‘ LockRecord çš„æŒ‡é’ˆ
3. CAS åŸå­æ›¿æ¢ï¼šåˆ¤æ–­å¯¹è±¡çš„ mark word å¯¹åº”åœ°å€çš„å€¼ï¼Œçœ‹æ˜¯å¦ä¸ºç¬¬ä¸€æ­¥å–åˆ°çš„ mark wordï¼Œå¦‚æœæ˜¯åˆ™æ›¿æ¢æˆåŠŸ

æ›¿æ¢å¤±è´¥åˆ™è¯´æ˜ï¼šåœ¨ç¬¬ 1 æ­¥å’Œç¬¬ 3 æ­¥ä¹‹é—´ï¼Œé”å¯¹è±¡ mark word å¯¹åº”åœ°å€çš„å€¼å·²ç»è¢«æ”¹æ‰äº†

æ¯”å¦‚åœ¨è¿™ä¹‹é—´æœ‰å¦å¤–ä¸€ä¸ªçº¿ç¨‹åŠ é”ï¼Œå› ä¸ºå½“å‰çº¿ç¨‹è¿˜æœªé‡Šæ”¾æ‰é”ï¼Œæ‰€ä»¥è§¦å‘äº†é”è†¨èƒ€ï¼Œä¿®æ”¹äº†é”å¯¹è±¡çš„ mark word å€¼



**Anonymous**

åšä¸»æ‚¨å¥½ï¼Œæˆ‘çš„ç–‘é—®æ˜¯ï¼Œæ‚¨å†™åˆ°â€œè½»é‡çº§é”åŠ é”çš„å‰ææ˜¯é”å¯¹è±¡ä¸èƒ½å¸¦æœ‰åå‘ç‰¹å¾â€ï¼Œä½†æ˜¯å‡ºç°åå‘é”å‡çº§çš„æ—¶å€™ï¼Œæ­¤æ—¶mark-wordä¸åº”è¯¥æ˜¯ã€Thread-ID | 1 | 01ã€‘ï¼Œè¿™æ ·çš„å—ï¼Œè¿™ç§æƒ…å†µä¸‹ã€‚å¦å¤–ï¼Œåœ¨ç¦ç”¨åå‘é”çš„æ—¶å€™ï¼Œæ‰ä¼šå‡ºç°markwordä¸­æœ‰hashcodeçš„å­˜åœ¨ï¼Œå¦‚æœå¼€å§‹åå‘é”ï¼Œåˆå§‹çŠ¶æ€åº”è¯¥æ˜¯ã€null | 1 | 01ã€‘ï¼Œè¿™å’Œå›¾æ–‡ä¹Ÿä¸å¤ªç¬¦åˆï¼Œè¿˜æ˜¯è¯´æˆ‘ç†è§£é”™äº†

**gorden5566**

[@Anonymous](https://gorden5566.com/post/1019.html#5eeda78c8ebe65000884f9d9) , åœ¨æ²¡æœ‰å¼€å¯åå‘é”çš„æ—¶å€™ï¼ŒåŠ é”æ—¶ä¼šç›´æ¥è¿›å…¥ slow_enterï¼Œæ­¤æ—¶ä¸ä¼šæœ‰åå‘ç‰¹å¾

```c++
if (UseBiasedLocking) {
  // Retry fast entry if bias is revoked to avoid unnecessary inflation
  ObjectSynchronizer::fast_enter(h_obj, elem->lock(), true, CHECK);
} else {
  ObjectSynchronizer::slow_enter(h_obj, elem->lock(), CHECK);
}
```

å¦‚æœå¼€å¯äº†åå‘é”ï¼Œåˆ™ä¼šè¿›å…¥ fast_enterï¼Œåœ¨åŠ é”å¤±è´¥æ—¶ä¼šæ’¤é”€åå‘é”ï¼Œå°† mark word æ¢å¤åˆ°æ— é”çŠ¶æ€æˆ–è®¾ç½®ä¸ºè½»é‡çº§é”çŠ¶æ€

æ–‡ç« é‡Œä¸»è¦è®¨è®ºçš„æ˜¯ slow_enter é‡Œè½»é‡çº§é”åŠ é”ã€è§£é”çš„è¿‡ç¨‹ï¼Œå…³äºåå‘é”çš„å¤„ç†å¯ä»¥çœ‹ä¸‹ fast_enter çš„ä»£ç é€»è¾‘



**Akashi**

åšä¸»éº»çƒ¦è¯·é—®ä¸€ä¸‹ï¼Œè½»é‡çº§é”åŠ é”çš„æ—¶å€™çŠ¶æ€æ˜¯ä»€ä¹ˆæ—¶å€™æ”¹çš„å‘¢ï¼ŸåŠ å®Œé”è¿˜æ˜¯å¤„äºæ— é”çŠ¶æ€å—ï¼ˆ001ï¼‰
æˆ‘æ‰¾äº†åŠå¤©å®åœ¨æ˜¯æ²¡æ‰¾åˆ°å“ªé‡Œæœ‰æ”¹çŠ¶æ€çš„â€¦â€¦.

**gorden5566**

[@Akashi](https://gorden5566.com/post/1019.html#5edd3076c141340006673999) , æ˜¯é€šè¿‡ CAS è®¾ç½® Lock Record åœ°å€æ—¶è®¾ç½®çš„

```c
if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()->mark_addr(), mark)) {
    TEVENT (slow_enter: release stacklock) ;
    return ;
}
```

è®¾ç½®å®Œä¹‹åï¼Œé”å¯¹è±¡çš„ Mark Word å­˜å‚¨çš„æ˜¯æŒ‡å‘åŠ é”çº¿ç¨‹çš„ Lock Record çš„æŒ‡é’ˆ

å› ä¸ºè½»é‡çº§é”çš„é”æ ‡å¿—ä½ä¸º `00`ï¼Œæ‰€ä»¥æ­¤æ—¶ Mark Word çš„äºŒè¿›åˆ¶åä¸¤ä½åº”ä¸º `00`

è¿™æ ·å¯ä»¥åæ¨å‡º Lock Record çš„åœ°å€æœ«ä¸¤ä½æ˜¯ `00`ï¼Œä¹Ÿå°±æ˜¯ 4 çš„å€æ•°

ä» BasicObjectLock å®šä¹‰çš„æ³¨é‡Šæ¥çœ‹ï¼Œ`BasicLock _lock` ä¹Ÿå°±æ˜¯ Lock Record å¿…é¡»æŒ‰ä¸¤ä¸ªå­—å¯¹é½ï¼Œè¿™ä¹Ÿç¬¦åˆå‰é¢çš„æ¨æµ‹

```c
// A BasicObjectLock associates a specific Java object with a BasicLock.
// It is currently embedded in an interpreter frame.

// Because some machines have alignment restrictions on the control stack,
// the actual space allocated by the interpreter may include padding words
// after the end of the BasicObjectLock.  Also, in order to guarantee
// alignment of the embedded BasicLock objects on such machines, we
// put the embedded BasicLock at the beginning of the struct.
class BasicObjectLock VALUE_OBJ_CLASS_SPEC {
friend class VMStructs;
private:
BasicLock _lock; // the lock, must be double word aligned
oop _obj; // object holds the lock;
```



**bobo**

è°¢è°¢æ¥¼ä¸»çš„åšå®¢ï¼Œå†™çš„è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°ã€‚æŒ‰ç…§è‡ªå·±çš„ç†è§£ï¼ŒæŒ‡å‡ºä¸€ä¸ªå°é—®é¢˜ï¼šğŸ˜€

â€œè½»é‡çº§é”æ˜¯å¯¹ synchronized çš„ä¸€ç§ä¼˜åŒ–æœºåˆ¶ï¼Œå®ƒé€‚ç”¨äºæ²¡æœ‰å¤šçº¿ç¨‹ç«äº‰çš„æƒ…å†µã€‚â€ åå‘é”æ‰é€‚ç”¨äºæ²¡æœ‰å¤šçº¿ç¨‹ç«äº‰çš„æƒ…å†µï¼Œè½»é‡çº§é”å’Œé‡é‡çº§é”å‡ç”¨äºå¤šçº¿ç¨‹åœºæ™¯ï¼ŒåŒºåˆ«åœ¨äºé‡é‡çº§é”ä¾èµ–æ“ä½œç³»ç»Ÿè¯­ä¹‰ï¼Œåœ¨æ— æ³•è·å–é”æ—¶ï¼Œçº¿ç¨‹ç›´æ¥è¿›å…¥é˜»å¡çŠ¶æ€ï¼› è€Œè½»é‡çº§é”ä¼šè‡ªæ—‹ä¸€æ®µæ—¶é—´ï¼Œå°è¯•è·å–é”ï¼Œè¶…æ—¶åå†è½¬ä¸ºé‡é‡çº§é”ã€‚

**gorden5566**

[@bobo](https://gorden5566.com/post/1019.html#5e6ca09791db2800773ed57a) , æ„Ÿè°¢æŒ‡æ­£ï¼Œè¿™é‡Œæè¿°çš„ç¡®å®ä¸å‡†ç¡® ğŸ˜…
åœ¨è½»é‡çº§é”çŠ¶æ€ä¸‹ï¼Œå¦‚æœçº¿ç¨‹ CAS ä¿®æ”¹ MarkWord å¤±è´¥ï¼ˆè·å–é”å¤±è´¥ï¼‰ï¼Œåˆ™ä¼šé€šè¿‡è‡ªæ—‹ç»§ç»­å°è¯•ï¼Œè‹¥ä»ç„¶å¤±è´¥åˆ™éœ€å‡çº§ä¸ºé‡é‡çº§é”ã€‚
å› æ­¤åœ¨ç«äº‰æ¯”è¾ƒå¼±çš„æƒ…å†µä¸‹ï¼Œç”±äºä¸é˜»å¡çº¿ç¨‹ï¼Œä½¿ç”¨è½»é‡çº§é”å“åº”ä¼šæ›´å¿«ã€‚åœ¨ç«äº‰æ¯”è¾ƒæ¿€çƒˆçš„æƒ…å†µä¸‹ï¼Œç›¸å¯¹äºç›´æ¥ä½¿ç”¨é‡é‡çº§é”ï¼Œé¢å¤–å¤šäº†è‡ªæ—‹è¿›è¡Œ CAS çš„å¼€é”€ï¼Œå“åº”ä¼šæ›´æ…¢äº›ã€‚ä¸è¿‡è½»é‡çº§é”ä¸€æ—¦å‡çº§æˆé‡é‡çº§é”ï¼Œå°±ä¸ä¼šå†æ¢å¤å›å»ï¼Œè¿™æ ·å°±é¿å…äº†æ›´å¤šæ— ç”¨çš„è‡ªæ—‹æ“ä½œã€‚



**Anonymous**

[@gorden5566](https://gorden5566.com/post/1019.html#5e73af2f21460d006b2240d8) , è¯·é—®æˆ‘åœ¨ä½ æ¨èçš„ æ­»ç£•æºç é‡Œé¢æ€ä¹ˆæ²¡æœ‰çœ‹åˆ°è‡ªæ—‹æ“ä½œå‘¢ï¼Ÿè¯·é—®ä½ æœ‰çœ‹åˆ°å—ï¼Ÿ

[@bobo](https://gorden5566.com/post/1019.html#5e6ca09791db2800773ed57a) , æºç é‡Œæ²¡çœ‹åˆ°è½»é‡çº§é”æœ‰è‡ªæ—‹æ“ä½œå”‰ï¼Œè¯·é—®ä½ æœ‰çœ‹åˆ°å—ï¼Ÿ

**gorden5566**

[@Anonymous](https://gorden5566.com/post/1019.html#5eac0145e0a51f00071b7615) , è·å–è½»é‡çº§é”å¤±è´¥æ—¶ä¼šå…ˆ **1.é”è†¨èƒ€** å†è¿›å…¥ **2.é‡é‡çº§é”åŠ é”è¿‡ç¨‹**

```java
ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);
```

1. é”è†¨èƒ€æ—¶ï¼Œå¦‚æœé”çŠ¶æ€ä¸º INFLATING æˆ–è€…å°è¯•ä¿®æ”¹é”çŠ¶æ€ä¸º INFLATING å¤±è´¥ï¼Œåˆ™ä¼šè¿›è¡Œå¾ªç¯å°è¯•

2. é‡é‡çº§é”åŠ é”æ—¶ï¼Œå…ˆå°è¯• cas è·å–é”ï¼Œå¦‚æœå¤±è´¥å†è‡ªæ—‹è·å–é”ï¼Œæœ€åæ‰ä¼šè¿›å…¥é˜»å¡é˜Ÿåˆ—ç­‰å¾…

   ```java
   // Try one round of spinning *before* enqueueing Self
   // and before going through the awkward and expensive state
   // transitions.  The following spin is strictly optional ...
   // Note that if we acquire the monitor from an initial spin
   // we forgo posting JVMTI events and firing DTRACE probes.
   if (Knob_SpinEarly && TrySpin (Self) > 0) {
     assert (_owner == Self      , "invariant") ;
     assert (_recursions == 0    , "invariant") ;
     assert (((oop)(object()))->mark() == markOopDesc::encode(this), "invariant") ;
     Self->_Stalled = 0 ;
     return ;
   }
   ```

   ä»¥ä¸Šæ˜¯ä¸ªäººè¯»çš„ jdk8u æºç ï¼Œä»…ä¾›å‚è€ƒ