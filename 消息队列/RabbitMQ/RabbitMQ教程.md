# RabbitMQ教程







## 1. 消息的可靠性如何保证

**发送端**

1. 需要RabbitMQ发送端确认机制，确认消息成功发送到RabbitMQ并被处理。 （如果没有正确发送，要返回报错信息，提醒业务方处理）
2. 需要RabbitMQ消息返回机制，如果没有路由到对应的队列，中间件会通知发送端。（也应该要返回报错信息，提醒业务方处理）





### 1.1 发送端确认原理

在使用RabbitMQ的时候，可以通过**消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失**，除此之外，我们还会遇到一个问题，**当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢**?**如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器**。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化?RabbitMQ针对这个问题，提供了两种解决方式:

- 通过事务机制实现:
- 通过发送方确认Cpublisherconfirm)机制实现。



#### 1.1.1 事务机制

RabbitMQ客户端中与事务机制相关的方法有三个:**channel.txSelect**、**channel.txCommit**和**channel.txRollbackochannel.txSelect**用于将当前的信道

设置成**事务模式**，**channel.txCommit用于提交事务**，**channel.txRollback用于事务回滚**。在通过channel.txSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了，**如果事务提交成功，则消息一定到达了RabbitMQ中**，**如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.txRollback方法来实现事务回滚**。注意这里的RabbitMQ中的事务机制与大多数数据库中的事务概念井不相同，需要注意区分。

**事务确实能够解决消息发送方和RabbitMQ之间消息确认的问题，只有消息成功被RabbitMQ接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。但是使用事务机制会"吸干"RabbitMQ的性能，那么有没有更好的方法既能保证消息发送方确认消息已经正确送达，又能基本上不带来性能上的损失呢?从AMQP协议层面来看并没有更好的办法，但是RabbitMQ提供了一个改进方案，即发送方确认机制，详情请看下一节的介绍。**



#### 1.1.2 发送方确认机制

前面介绍了RabbitMQ可能会遇到的一个问题，即消息发送方（生产者）并不知道消息是否真正地到达了RabbitMQ。随后了解到在AMQP协议层面提供了事务机制来解决这个问题，但是采用事务机制实现会严重降低RabbitMQ的消息吞吐量，这里就引入了一种轻量级的方式——**发送方确认（publisher confirm）**机制。

生产者将信道设置成**confirm** （确认）模式，一旦信道进入confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者(包含消息的唯一ID)，这就使得生产者知晓消息已经正确到达了目的地了。**如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出**。RabbitMQ回传给生产者的确认消息中的**deliveryTag包含了确认消息的序号**，此外RabbitMQ也可以设置channel.basicAck方法中的multiple参数，表示到这个序号之前的所有消息都己经得到了处理。



**事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息**。**相比之下，发送方确认机制最大的好处在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nackCBasic. Nack)命令，生产者应用程序同样可以在回调方法中处理该nack命令。**



**注意要点:**

> ( 1 )事务机制和 publisher confirm机制两者是互斥的，不能共存。
>
>  (2 )事务机制和 publisher confirm 机制确保的是消息能够正确地发送至RabbitMQ，这里的"发送至RabbitMQ"的含义是指消息被正确地发往至RabbitMQ的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列。更进一步地讲，发送方要配合mandatory参数或者备份交换器一起使用来提高消息传输的可靠性



publisher confirm 的优势在于并不一定需要同步确认。这里我们改进了一下使用方式，总结有如下两种:

1. **批量confirm方法**:每发送一批消息后，调用channel.waitForConfirms方法，等待服务器的确认返回。
2. **异步confirm方法**:提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法进行处理。

在批量confirm方法中，客户端程序需要定期或者定量(达到多少条)，亦或者两者结合起来调用channel.waitForConfirms来等待RabbitMQ的确认返回。相比于前面示例中的普通confirm方法，批量极大地提升了confmn的效率，但是问题在于出现返回Basic.Nack或者超时情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且当消息经常丢失时，批量confirm的性能应该是不升反降的。

**异步回调确认**，可能是单条通知，也可能是多条通知，这个是由RabbitMQ以当时的情况决定的。（我们有些业务，已经处理完成了，**但是异步通知回来告诉我们失败了，这个就比较麻烦**，如果返回多条消息中，有多条消息是失败的,是哪几条消息失败了，还要去查询数据库，查找**deliverytag**来判断，所以也不是很推荐。但是异步方式，这种解耦的思想，如果符合你的某些业务场景，可以考虑使用）



### 1.2 消息真的被路由了吗

